---
title: (íŒŒì´ì¬ S/W ë¬¸ì œí•´ê²° ê¸°ë³¸) Queue - 5097ë²ˆ 5105ë²ˆ 5099ë²ˆ 5102ë²ˆ
date: 2019-09-02 19:11:35
categories:
  - ALGORITHM ğŸ¯
  - SW ì•„ì¹´ë°ë¯¸
tags: [ì‚¼ì„±, íŒŒì´ì¬, SW Academy, python, queue]
subtitle: (Programming Intermediate) íŒŒì´ì¬ S/W ë¬¸ì œí•´ê²° ê¸°ë³¸ 6ì¼ì°¨
---

# 5097ë²ˆ - íšŒì „

{% note %}

- ì‹œê°„ : 10ê°œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ í•©ì³ì„œ Pythonì˜ ê²½ìš° 2ì´ˆ
- ë©”ëª¨ë¦¬ : í™, ì •ì  ë©”ëª¨ë¦¬ í•©ì³ì„œ 256MB ì´ë‚´, ìŠ¤íƒ ë©”ëª¨ë¦¬ 1MB ì´ë‚´
  {% endnote %}

> ë¦¬ìŠ¤íŠ¸ ë‚´ì¥í•¨ìˆ˜ì¸ pop()ê³¼ append()ë¡œ ì‰½ê²Œ í•´ê²°

{% note success %}
{% code lang:python %}
T = int(input())

for test_case in range(1, T+1): # ì…ë ¥ ê¸¸ì´ N, íšŒì „ ìˆ˜ M
N, M = map(int, input().split())
seq_lst = [num for num in input().split()]

    # Më²ˆ ë°˜ë³µ
    for _ in range(M):
        # ë§¨ ì• ì›ì†Œë¥¼ ë¹¼ì„œ pop(), ë§¨ ë’¤ë¡œ ì¶”ê°€ append()
        seq_lst.append(seq_lst.pop(0))

    print('#{} {}'.format(test_case, seq_lst))

{% endcode %}
{% endnote %}

---

# 5105ë²ˆ - ë¯¸ë¡œì˜ ê±°ë¦¬

{% note %}

- ì‹œê°„ : 10ê°œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ í•©ì³ì„œ Pythonì˜ ê²½ìš° 2ì´ˆ
- ë©”ëª¨ë¦¬ : í™, ì •ì  ë©”ëª¨ë¦¬ í•©ì³ì„œ 256MB ì´ë‚´, ìŠ¤íƒ ë©”ëª¨ë¦¬ 1MB ì´ë‚´
  {% endnote %}

> ì§€ë‚œ ë¯¸ë¡œ ë¬¸ì œëŠ” DFS, ì´ë²ˆì—ëŠ” BFSë¡œ í•´ê²°
> DFSëŠ” ì¬ê·€ì ìœ¼ë¡œ, BFSëŠ” ë°˜ë³µì„ í†µí•´ ì ‘ê·¼

{% note success %}
{% code lang:python %}
def BFS(x, y): # í˜„ì¬ ì¢Œí‘œ ë“±ë¡
path.append((x, y))
visited.append((x, y))

    while path:
        # ê²½ë¡œ ë§¨ ì• ì›ì†Œ ì œê±°
        cur_x, cur_y = path.pop(0)

        for i in range(4):
            next_x = cur_x + dx[i]
            next_y = cur_y + dy[i]

            if (next_x, next_y) not in visited and (0<=next_x<N and 0<=next_y<N) and maze[next_y][next_x] != 1:
                if maze[next_y][next_x] == 3:
                    return path_len[cur_x][cur_y]

                path.append((next_x, next_y))
                visited.append((next_x, next_y))
                path_len[next_x][next_y] = path_len[cur_x][cur_y] + 1

def findStart():
for y in range(N):
for x in range(N):
if maze[y][x] == 2:
return x, y

T = int(input())

for test*case in range(1, T+1): # ë¯¸ë¡œì˜ í¬ê¸°
N = int(input())
maze = [[int(num) for num in input()] for * in range(N)]

    # ì‹œì‘ì  ì°¾ê¸°
    startX, startY = findStart()

    # ë°©ë¬¸ì²´í¬, ê²½ë¡œ í, ê²½ë¡œ ê¸¸ì´ ë¦¬ìŠ¤íŠ¸
    visited, path, path_len = [], [], [[0]*N for _ in range(N)]

    # ì‹œê³„ë°©í–¥ (ìš°, í•˜, ì¢Œ, ìƒ)
    dx = [1, 0, -1, 0]
    dy = [0, -1, 0, 1]

    ans = BFS(startX, startY)
    if ans is None:
        ans = 0

    print('#{} {}'.format(test_case, ans))

{% endcode %}
{% endnote %}

---

# 5099ë²ˆ - í”¼ì êµ½ê¸°

{% note %}

- ì‹œê°„ : 10ê°œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ í•©ì³ì„œ Pythonì˜ ê²½ìš° 2ì´ˆ
- ë©”ëª¨ë¦¬ : í™, ì •ì  ë©”ëª¨ë¦¬ í•©ì³ì„œ 256MB ì´ë‚´, ìŠ¤íƒ ë©”ëª¨ë¦¬ 1MB ì´ë‚´
  {% endnote %}

> í™”ë•ì„ ëŒë ¤ê°€ë©° í”¼ìë¥¼ êµ½ì

{% note success %}
{% code lang:python %}
def pizza(): # ì´ˆê¸° í™”ë• í
oven = [] # í”¼ì ë²ˆí˜¸
pNum = 0

    # (init) ë¹ˆ í™”ë•ì— í”¼ì ì±„ìš°ê¸°
    for _ in range(N):
        oven.append([C[pNum], pNum])
        pNum += 1

    # (ë°˜ë³µ) ì˜¤ë¸ì— ë§ˆì§€ë§‰ í”¼ìë§Œ ë‚¨ì„ ë•Œ ê¹Œì§€
    while len(oven) != 1:
        # í˜„ì¬ í™”ë• í™•ì¸ìœ¼ë¡œ ì¹˜ì¦ˆê°€ ë°˜ ë…¹ìŒ
        oven[0][0] = oven[0][0] // 2

        # ì¹˜ì¦ˆê°€ ë‹¤ ë…¹ì•˜ë‹¤ë©´
        if oven[0][0] == 0:
            # êº¼ë‚´ê³ 
            oven.pop(0)
            # í”¼ìê°€ ë‚¨ì•˜ë‹¤ë©´
            if pNum != len(C):
                # í™”ë•ì— ë„£ì–´ì¤€ë‹¤
                oven.append([C[pNum], pNum])
                pNum += 1
        # ëœ ë…¹ì•˜ìœ¼ë©´ íšŒì „
        else:
            oven.append(oven.pop(0))

    return oven[0][1] + 1

T = int(input())

for test_case in range(1, T+1): # í™”ë•ì˜ í¬ê¸° N, í”¼ì ê°œìˆ˜ M
N, M = map(int, input().split()) # ì¹˜ì¦ˆì˜ ì–‘ C
C = [int(amount) for amount in input().split()]

    print('#{} {}'.format(test_case, pizza()))

{% endcode %}
{% endnote %}

---

# 5102ë²ˆ - ë…¸ë“œì˜ ê±°ë¦¬

{% note %}

- ì‹œê°„ : 10ê°œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ í•©ì³ì„œ Pythonì˜ ê²½ìš° 2ì´ˆ
- ë©”ëª¨ë¦¬ : í™, ì •ì  ë©”ëª¨ë¦¬ í•©ì³ì„œ 256MB ì´ë‚´, ìŠ¤íƒ ë©”ëª¨ë¦¬ 1MB ì´ë‚´
  {% endnote %}

> ì „ì—­ë³€ìˆ˜ 'ans'ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  BFS() í•¨ìˆ˜ì—ì„œ return path_len[]ë¥¼ í•˜ë©´ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¤‘ í•˜ë‚˜ê°€ ì˜¤ë‹µì´ ëœë‹¤
> ê°„ì„ ì´ ì—†ëŠ” ê²½ìš°ì¸ê±° ê°™ì€ë°...

{% note success %}
{% code lang:python %}
def makeGraph():
graph = {key + 1: set() for key in range(V)}

    for _ in range(E):
        key, val = map(int, input().split())
        graph[key].add(val)
        graph[val].add(key)

    return graph

def BFS(s, g):
global ans
path.append(s)
visited[s] = True

    while path:
        node = path.pop(0)

        for next_node in myGraph[node]:
            if not visited[next_node]:
                path.append(next_node)
                visited[next_node] = True
                path_len[next_node] = path_len[node] + 1

                if next_node == g:
                    ans = path_len[next_node]
                    return
    return

T = int(input())

for test_case in range(1, T+1):
V, E = map(int, input().split())
myGraph = makeGraph()
S, G = map(int, input().split())

    path = []
    visited = [False] * (V+1)
    path_len = [0] * (V+1)
    ans = 0
    BFS(S, G)

    print('#{} {}'.format(test_case, ans))

{% endcode %}
{% endnote %}

---
