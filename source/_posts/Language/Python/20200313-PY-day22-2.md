---
title: (PYTHON) Day - 22 Regex and Parsing(2)
date: 2020-03-13 21:15:15
categories:
  - LANGUAGE ğŸš€
  - PYTHON
  - HACKERRANK
tags: [íŒŒì´ì¬, programming language, python, language]
subtitle: ê¸°ì´ˆë¥¼ íƒ„íƒ„íˆ!
---

# Reference

- ë¬¸ì œ ì¶œì²˜ - [HackerRank](https://www.hackerrank.com/dashboard)
- íŒŒì´ì¬ ì—°ìŠµ - [Practice - Python](https://www.hackerrank.com/domains/python?filters%5Bstatus%5D%5B%5D=unsolved&badge_type=python)

ê°œì¸ì ì¸ ìƒê°ê³¼ ìƒìƒìœ¼ë¡œ ì‘ì„±í•œ ë‚´ìš©ë“¤ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤
ë¬¸ì œë¥¼ í’€ê³  {% label success@ Discussion Tab %}ì„ ì°¸ê³ í•˜ë©° ì½”ë“œ ìŠ¤íƒ€ì¼ì„ ê°œì„ í•˜ë ¤ê³  ë…¸ë ¥í•˜ê³ ì í•©ë‹ˆë‹¤

---

# HackerRank

{% spoiler "HackerRankì˜ Python ì—°ìŠµë¬¸ì œë“¤ì€ ì•„ë˜ì™€ ê°™ì€ ì¹´í…Œê³ ë¦¬ë¡œ ë¶„ë¥˜ ëœë‹¤" %}

## Subdomain

    - ~~Introduction~~
    - ~~Basic Data Types~~
    - ~~Strings~~
    - ~~Sets~~
    - ~~Math~~
    - ~~Itertools~~
    - ~~Collections~~
    - ~~Date and Time~~
    - ~~Errors and Exceptions~~
    - ~~Classes~~
    - ~~Built-Ins~~
    - ~~Python Functionals~~
    - <strong style="color:blue">Regex and Parsing</strong>
    - XML
    - Closures and Decorators
    - Numpy
    - Debugging

{% endspoiler %}

---

# Regex and Parsing

{% note no-icon %}
{% note primary no-icon %}

## Problem

- [Detect Floating Point Number](#Detect-Floating-Point-Number)
- [Re.split()](#Re-split)
- [Group(), Groups() & Groupdict()](#Group-Groups-amp-Groupdict)
- [Re.findall() & Re.finditer()](#Re-findall-amp-Re-finditer)
- [Re.start() & Re.end()](#Re-start-amp-Re-end)
- [Regex Substitution](#Regex-Substitution)
- [Validating Roman Numerals](#Validating-Roman-Numerals)
- [Validating phone numbers](#Validating-phone-numbers)
- [Validating and Parsing Email Addresses](#Validating-and-Parsing-Email-Addresses)
  {% endnote %}

---

## Detect Floating Point Number

</br>

{% note info %}
ë¬¸ì œ : ì…ë ¥ì´ í˜•ì‹ì— ë§ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ì…ë ¥ë°›ì„ ê°œìˆ˜ N; (N ë°˜ë³µ) ë¬¸ìì—´;
ì¶œë ¥ : ê° ë¬¸ìì—´ì´ í˜•ì‹ì— ë§ëŠ”ì§€ True/False ë¡œ ì¶œë ¥
í˜•ì‹ :

1. ìˆ«ìëŠ” +/-/. ìœ¼ë¡œ ì‹œì‘ í•  ìˆ˜ ìˆë‹¤
2. ìˆ«ìëŠ” ìµœì†Œ 1ê°œì˜ ì†Œìˆ˜ì  ì•„ë˜ ê°’ì„ ê°€ì§„ë‹¤(ì¦‰, ì •ìˆ˜ê°€ ì•„ë‹˜)
3. float() íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•  ë•Œ ì˜¤ë¥˜ê°€ ì—†ì–´ì•¼ í•œë‹¤
   {% endnote %}

{% tabs example1, -1 %}

  <!-- tab INPUT @code -->

4
4.0O0
-1.00
+4.54
SomeRandomStuff

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

False
True
True
False

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
ì •ê·œí‘œí˜„ì‹ ê¸°í˜¸ë¥¼ ì˜ ì™¸ìš°ì
{% code lang:python %}
'''
^: ì‹œì‘ì„ ë‚˜íƒ€ëƒ„
[+-]?: (`+` í˜¹ì€ `-`) ë‘˜ ì¤‘ í•˜ë‚˜ê°€ ìˆê±°ë‚˜ ì—†ì„ ìˆ˜ ìˆë‹¤
\d\*: ìˆ«ìê°€ ìˆì„ ìˆ˜ë„ ìˆê³  ì—†ì„ ìˆ˜ë„ ìˆë‹¤ <- \dëŠ” [0-9]ë¡œ í‘œí˜„í•  ìˆ˜ë„ ìˆë‹¤
\.: `.` ë¬¸ì
\d+: ì ì–´ë„ í•˜ë‚˜ì˜ ìˆ«ìê°€ ìˆë‹¤
$: ëì„ ë‚˜íƒ€ëƒ„
'''

import re

for \_ in range(int(input())):
n = input()
print(bool(re.search(r'^[+-]?\d*\.\d+$', n))) # print(bool(re.search(r'^[+-]?[0-9]*\.[0-9]+$', n))) {% endcode %}
{% endnote %}

---

## Re.split()

</br>

{% note info %}
ë¬¸ì œ : ì‰¼í‘œë‚˜ ì ì„ êµ¬ë¶„í•˜ëŠ” ì •ê·œí‘œí˜„ì‹
{% endnote %}

{% tabs example2, -1 %}

  <!-- tab INPUT @code -->

100,000,000.000

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

100
000
000
000

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
ê·¸ëƒ¥ ë‚´ì¥í•¨ìˆ˜ë¡œë„ êµ¬í˜„í•  ìˆ˜ ìˆì§€ ì•Šë‚˜?
{% code lang:python %}
print(\*input().replace(',', '.').split('.'), sep='\n') {% endcode %}
{% endnote %}

{% note success no-icon %}
ì–´ì¨Œë“  ì •ê·œí‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤
{% code lang:python %}
regex_pattern = r'[\.\,]'

import re
print("\n".join(re.split(regex_pattern, input()))){% endcode %}
{% endnote %}

---

## Group(), Groups() & Groupdict()

</br>

{% note info %}
ë¬¸ì œ : ì²˜ìŒìœ¼ë¡œ ì—°ì† ë°˜ë³µë˜ëŠ” ì˜ë¬¸ì í˜¹ì€ ìˆ«ìë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ë¬¸ìì—´
ì¶œë ¥ : ë°˜ë³µë˜ëŠ” ì²« ì˜ìˆ«ì(ì—†ë‹¤ë©´ -1 ì¶œë ¥)
ì˜ˆì œ : .ì€ ë°˜ë³µë˜ì§€ë§Œ ì˜ìˆ«ì(alphanumeric)ê°€ ì•„ë‹˜, 111ì´ ë°˜ë³µë˜ë¯€ë¡œ ë‹µì€ 1
{% endnote %}

{% tabs example3, -1 %}

  <!-- tab INPUT @code -->

..12345678910111213141516171820212223

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

1

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
3ê°€ì§€ í‘œí˜„ì´ ê°€ëŠ¥í•¨
{% code lang:python %}
import re

# S = re.search(r"([A-Za-z0-9])\1+", input())

# S = re.search(r"(\w(?!\_))\1+", input())

S = re.search(r"([^\w_])\1+", input())

# print(S[1] if S else -1)

print(S.group(1) if S else -1){% endcode %}
{% endnote %}

---

## Re.findall() & Re.finditer()

</br>

{% note info %}
ë¬¸ì œ : ë¬¸ìì—´ì—ì„œ ì–‘ëì´ ììŒ(consonant)ì´ë©´ì„œ 2ê°œì˜ ëª¨ìŒ(vowel)ì„ í¬í•¨í•˜ëŠ” ì„œë¸Œ ë¬¸ìì—´ì„ ì°¾ëŠ” ë¬¸ì œ
ì…ë ¥ : ê³µë°±, +, - ë¥¼ í¬í•¨í•˜ëŠ” ë¬¸ìì—´
ì¶œë ¥ : ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë¬¸ìì—´
{% endnote %}

{% tabs example4, -1 %}

  <!-- tab INPUT @code -->

rabcdeefgyYhFjkIoomnpOeorteeeeet

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

ee
Ioo
Oeo
eeeee

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
ëª¨ë²” ë‹µì•ˆ
ì¡°ê±´ì´ ìˆëŠ” í‘œí˜„ì‹(`?<=` ì™€ ê°™ì€) ì„ ì˜ ìˆ™ì§€í•  ê²ƒ
ì»´íŒŒì¼ ì˜µì…˜ìœ¼ë¡œ `re.IGNORECASE` ë¥¼ ì‚¬ìš©í•˜ì—¬ ëŒ€ì†Œë¬¸ìë¥¼ êµ¬ë¶„í•˜ì§€ ì•Šì•„ë„ ë¨
{% code lang:python %}
import re

VOWELS = 'aeiou'
CONSONANTS = 'bcdfghjklmnpqrstvwxyz'
REGEX = '(?<=[' + CONSONANTS + '])([' + VOWELS + ']{2,})[' + CONSONANTS + ']'

match = re.findall(REGEX, input(), re.IGNORECASE)
if match:
print(\*match, sep='\n')
else:
print('-1') {% endcode %}
{% endnote %}

---

## Re.start() & Re.end()

</br>

{% note info %}
ë¬¸ì œ : ì°¾ëŠ” ë¬¸ìì—´ì˜ ìœ„ì¹˜(ë²”ìœ„)ë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ë¬¸ìì—´ S; ì°¾ê³ ì í•˜ëŠ” ë¬¸ìì—´ k;
ì¶œë ¥ : Sì—ì„œ kë¬¸ìì—´ì˜ ìœ„ì¹˜ë“¤
{% endnote %}

{% tabs example5, -1 %}

  <!-- tab INPUT @code -->

aaadaa
aa

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

(0, 1)  
 (1, 2)
(4, 5)

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
ì¡°ê¸ˆ ë¹„íš¨ìœ¨ì ì¸ ë°©ë²•ì¸ ê²ƒ ê°™ë‹¤ã… 
{% code lang:python %}
import re

S = input()
k = input()
pattern = re.compile(k)
searched = pattern.search(S)

if searched is None:
print(-1, -1)
else:
for i in range(len(S)):
if pattern.match(S[i:]):
print((i,i+len(k)-1)) {% endcode %}
{% endnote %}

{% note success no-icon %}
ì¡°ê¸ˆ ì •ë¦¬í•œ ë²„ì „
{% code lang:python %}
import re

S = input()
k = input()

pattern = re.compile(k)
r = pattern.search(S)

if not r:
print((-1, -1))
while r:
print("({0}, {1})".format(r.start(), r.end() - 1))
r = pattern.search(S, r.start() + 1) {% endcode %}
{% endnote %}

---

## Regex Substitution

</br>

{% note info %}
ë¬¸ì œ : ê¸°í˜¸ë¥¼ ë¬¸ìë¡œ ë°”ê¾¸ëŠ” ë¬¸ì œ (&& â†’ and, || â†’ or)
ì…ë ¥ : ì…ë ¥ì¤„ ìˆ˜ N; (N ë°˜ë³µ) ë¬¸ìì—´;
ì¶œë ¥ : ë°”ë€ ë¬¸ìì—´
{% endnote %}

{% tabs example6, -1 %}

  <!-- tab INPUT @code -->

11
a = 1;
b = input();

if a + b > 0 && a - b < 0:
start()
elif a\*b > 10 || a/b < 1:
stop()
print set(list(a)) | set(list(b))
#Note do not change &&& or ||| or & or |
#Only change those '&&' which have space on both sides.
#Only change those '|| which have space on both sides.

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

a = 1;
b = input();

if a + b > 0 and a - b < 0:
start()
elif a\*b > 10 or a/b < 1:
stop()
print set(list(a)) | set(list(b))
#Note do not change &&& or ||| or & or |
#Only change those '&&' which have space on both sides.
#Only change those '|| which have space on both sides.

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
í•´ë‹¹ ë‹¨ì›ì—ì„œëŠ” ì •ê·œì‹ ì‚¬ìš©í•´ì„œ í‘¸ëŠ” ê²ƒì„ ê¶Œì¥í•˜ì§€ë§Œ, ì´ ë¬¸ì œëŠ” êµ³ì´ ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ë  ê²ƒ ê°™ë‹¤
{% code lang:python %}
for \_ in range(int(input())):
line = input()

    while ' && ' in line or ' || ' in line:
        line = line.replace(" && ", " and ").replace(" || ", " or ")

    print(line)  {% endcode %}

{% endnote %}

{% note success no-icon %}
ì•ë’¤ ë¹ˆì¹¸ì„ ì‹ ê²½ì¨ì„œ ë¬¸ì œë¥¼ í’€ì–´ì•¼í•œë‹¤... ê·¸ëƒ¥ ìœ„ ë°©ì‹ì´ ë” ê¹”ë”í•œ ê²ƒ ê°™ë‹¤
{% code lang:python %}
import re

for \_ in range(int(input())):
S = input()
S = re.sub(r' &&(?= )', ' and', S)
S = re.sub(r' \|\|(?= )', ' or', S)
print(S)
{% endcode %}
{% endnote %}

---

## Validating Roman Numerals

</br>

{% note info %}
ë¬¸ì œ : ë¡œë§ˆìˆ«ìê°€ 4000ë³´ë‹¤ ì‘ì€ì§€ í™•ì¸í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ë¡œë§ˆìˆ«ì
ì¶œë ¥ : True/False
{% endnote %}

{% tabs example7, -1 %}

  <!-- tab INPUT @code -->

CDXXI

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

True

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
ë¡œë§ˆìˆ«ì ëª¨ë“ˆì´ ì¡´ì¬í•œë‹¤ëŠ” ê²ƒì„ ì²˜ìŒ ì•Œì•˜ë‹¤
{% code lang:python %}
from roman import fromRoman

try:
if 0<fromRoman(input())<4000:
print(True)
else:
print(False)
except:
print(False) {% endcode %}
{% endnote %}

{% note success no-icon %}
`rf''` ì´ë ‡ê²Œë„ ì‘ì„±ì´ ê°€ëŠ¥í•˜êµ¬ë‚˜... ê·¸ëƒ¥ ì ì–´ë´¤ëŠ”ë° ì—ëŸ¬ê°€ ì•ˆ ë‚˜ì„œ ì‹ ê¸°í–ˆë‹¤
{% code lang:python %}
thousand = 'M{0,3}'
hundred = '(C[MD]|D?C{0,3})'
ten = '(X[CL]|L?X{0,3})'
digit = '(I[VX]|V?I{0,3})'

regex_pattern = rf"{thousand}{hundred}{ten}{digit}$"

import re
print(str(bool(re.match(regex_pattern, input())))) {% endcode %}
{% endnote %}

---

## Validating phone numbers

</br>

{% note info %}
ë¬¸ì œ : 7,8,9 ë¡œ ì‹œì‘í•˜ë©° 10ìë¦¬ì¸ ì „í™”ë²ˆí˜¸ë¥¼ êµ¬ë¶„í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ë²ˆí˜¸ ê°œìˆ˜ N; (N ë°˜ë³µ) ë¬¸ìì—´;
ì¶œë ¥ : Yes/No
{% endnote %}

{% tabs example8, -1 %}

  <!-- tab INPUT @code -->

2
9587456281
1252478965

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

YES
NO

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
{% code lang:python %}
import re

for \_ in range(int(input())):
line = input()
if re.match(r"^[789]{1}\d{9}$", line):
print("YES")
else:
print("NO") {% endcode %}
{% endnote %}

---

## Validating and Parsing Email Addresses

</br>

{% note info %}
ë¬¸ì œ : ì–‘ì‹ì— ë§ëŠ” ì´ë©”ì¼ë§Œ êµ¬ë³„í•´ì„œ ì¶œë ¥
ì…ë ¥ : ì´ë©”ì¼ ê°œìˆ˜ n; (n ë°˜ë³µ) ì´ë¦„, ì´ë©”ì¼ ì£¼ì†Œ;
ì¶œë ¥ : name <user@email.com> í˜•ì‹
{% endnote %}

{% tabs example9, -1 %}

  <!-- tab INPUT @code -->

2  
 DEXTER <dexter@hotmail.com>
VIRUS <virus!@variable.:p>

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

DEXTER <dexter@hotmail.com>

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
ê·¸ëƒ¥ ì •ê·œì‹ë§Œ ì‚¬ìš©
{% code lang:python %}
import re
pattern=r'(?<=<)[a-z][a-z0-9\.\_\-]*@[a-z]+\.[a-z]{1,3}(?=>)'
for \_ in range(int(input())):
s = input()
if bool(re.search(pattern,s,re.IGNORECASE)):
print(s) {% endcode %}
{% endnote %}

{% note success no-icon %}
email.utils ëª¨ë“ˆ ì‚¬ìš©
{% code lang:python %}
import re
import email.utils
pattern=r'[a-z][a-z0-9\.\_\-]\*@[a-z]+\.[a-z]{1,3}$'
for \_ in range(int(input())):
tup=email.utils.parseaddr(input())
if bool(re.match(pattern,tup[1],re.IGNORECASE)):
print(email.utils.formataddr(tup)) {% endcode %}
{% endnote %}

{% endnote %}
