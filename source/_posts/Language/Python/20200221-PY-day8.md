---
title: (PYTHON) Day - 8 Strings(4)
date: 2020-02-21 13:45:48
categories:
  - LANGUAGE ğŸš€
  - PYTHON
  - HACKERRANK
tags: [íŒŒì´ì¬, programming language, python, language]
subtitle: ê¸°ì´ˆë¥¼ íƒ„íƒ„íˆ!
---

# Reference

- ë¬¸ì œ ì¶œì²˜ - [HackerRank](https://www.hackerrank.com/dashboard)
- íŒŒì´ì¬ ì—°ìŠµ - [Practice - Python](https://www.hackerrank.com/domains/python?filters%5Bstatus%5D%5B%5D=unsolved&badge_type=python)

ê°œì¸ì ì¸ ìƒê°ê³¼ ìƒìƒìœ¼ë¡œ ì‘ì„±í•œ ë‚´ìš©ë“¤ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤
ë¬¸ì œë¥¼ í’€ê³  {% label success@ Discussion Tab %}ì„ ì°¸ê³ í•˜ë©° ì½”ë“œ ìŠ¤íƒ€ì¼ì„ ê°œì„ í•˜ë ¤ê³  ë…¸ë ¥í•˜ê³ ì í•©ë‹ˆë‹¤

---

</br>

# HackerRank

HackerRankì˜ Python ì—°ìŠµë¬¸ì œë“¤ì€ ì•„ë˜ì™€ ê°™ì€ ì¹´í…Œê³ ë¦¬ë¡œ ë¶„ë¥˜ ëœë‹¤:

{% note default %}

## Subdomain

- ~~Introduction~~
- ~~Basic Data Types~~
- <strong style="color:blue">Strings</strong>
- Sets
- Math
- Itertools
- Collections
- Date and Time
- Errors and Exceptions
- Classes
- Built-Ins
- Python Functionals
- Regex and Parsing
- XML
- Closures and Decorators
- Numpy
- Debugging
  {% endnote %}

---

</br>

# Strings

{% note primary %}

## Problem

- [Capitalize!](#Capitalize!)
- [The Minion Game](#The-Minion-Game)
- [Merge the Tools!](#Merge-the-Tools!)  
  {% endnote %}

## ê¸°ë³¸ ê°œë…

### Capitalize!

{% note info %}
ë¬¸ì œ : ì‚¬ëŒ ì´ë¦„ì˜ ì²« ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ëŠ” ë¬¸ì œ
{% endnote %}

{% tabs example1 %}

  <!-- tab INPUT @code -->

chris alan

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

Chris Alan

  <!-- endtab -->

{% endtabs %}

{% note success %}
{%label default@ os íŒ¨í‚¤ì§€ëŠ” í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë‹¤ë£¨ë©´ì„œ í•œë²ˆ ì •ë¦¬í•  ì˜ˆì • %}
{% code lang:python %}
def solve(s):
return ' '.join(i.capitalize() for i in s.split(' '))

if **name** == '**main**':
fptr = open(os.environ['OUTPUT_PATH'], 'w')

      s = input()

      result = solve(s)

      fptr.write(result + '\n')

      fptr.close()  {% endcode %}

{% endnote %}

---

### The Minion Game

{% note info %}
ë¬¸ì œ : ë¬¸ìì—´ Së¥¼ ì…ë ¥ë°›ìœ¼ë©´ ë‘ ì‚¬ëŒ(Stuart, Kevin) ê°ê° ììŒ(consonant), ëª¨ìŒ(vowel)ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ ì¡°í•©ì˜ ì´ ê°œìˆ˜ë¥¼ ë¹„êµí•˜ì—¬ í° ì‚¬ëŒì˜ ì´ë¦„ê³¼ ê·¸ ìˆ«ìë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
ì˜ˆì œ : 'BANANA'ì—ì„œ 'ANA'ëŠ” 2ë²ˆ ë‚˜íƒ€ë‚˜ê¸° ë•Œë¬¸ì— scoreëŠ” 2ê°€ ëœë‹¤. ì•„ë˜ ê·¸ë¦¼ì„ ì°¸ê³ 
![minion game](https://s3.amazonaws.com/hr-challenge-images/9693/1450330231-04db904008-banana.png)
{% endnote %}

{% tabs example2 %}

  <!-- tab INPUT @code -->

BANANA

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

Stuart 12

  <!-- endtab -->

{% endtabs %}

{% note default %}
{% code lang:python %}
def minion_game(string):
player = {'Stuart': 0, 'Kevin': 0}
vowels = 'AEIOU'

    str_l = len(string)
    for i, c in enumerate(string):
      if c in vowels:
        player['Kevin'] += str_l - i
      else:
        player['Stuart'] += str_l - i

    if player['Stuart'] == player['Kevin']:
      print('Draw')
    elif player['Stuart'] > player['Kevin']:
      print('Stuart', player['Stuart'])
    else:
      print('Kevin', player['Kevin'])

if **name** == '**main**':
s = input()
minion_game(s) {% endcode %}
{% endnote %}

{% note success %}
Several optimizations.

- Use frozenset for the vowels. This is the fastest to lookup in.
- Iterate through characters instead of indexing
- Iterate q reverse to avoid a subtraction in each sum
- Avoid repeated calls to len
- Only calculate Kevins score the hard way. Use the fact that the total number of substrings is n \* (n + 1) / 2 and find Stuart's score by subtracting Kevin's from the total number of substrings.

  {% code lang:python %}
  def minion_game(s):
  V = frozenset("AEIOU")
  n = len(s)
  ksc = sum(q for c, q in zip(s, range(n, 0, -1)) if c in V)
  ssc = n \* (n + 1) // 2 - ksc
  if ksc > ssc:
  print("Kevin {:d}".format(ksc))
  elif ssc > ksc:
  print("Stuart {:d}".format(ssc))
  else:
  print("Draw"){% endcode %}
  {% endnote %}

---

### Merge the Tools!

{% note info %}
ì…ë ¥ : ë¬¸ìì—´ sì™€ ì •ìˆ˜ kë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤(këŠ” ë¬¸ìì—´ ê¸¸ì´(n)ì˜ ì•½ìˆ˜)
ì¶œë ¥ : kì˜ ë°°ìˆ˜ì— ìœ„ì¹˜í•œ ë¬¸ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ sub-ë¬¸ìì—´ì„ êµ¬ë¶„í•˜ê³  ë°˜ë³µë˜ëŠ” ë¬¸ìëŠ” ì‚­ì œí•´ì„œ ì¶œë ¥
ì˜ˆì œ : ë¬¸ìì—´ 'AABCAAADA'ì—ì„œ ê¸¸ì´ 3ìœ¼ë¡œ ìë¥´ë©´ 'AAB' 'CAA' 'ADA' 3ê°œì˜ sub-ë¬¸ìì—´ë¡œ ë‚˜ë‰˜ê³  ì—¬ê¸°ì„œ ì¤‘ë³µë˜ëŠ” ë¬¸ìë¥¼ ì œê±°í•˜ë©´ 'AB' 'CA' 'AD'ê°€ ëœë‹¤
{% endnote %}

{% tabs example3 %}

  <!-- tab INPUT @code -->

AABCAAADA
3

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

AB
CA
AD

  <!-- endtab -->

{% endtabs %}

{% note default %}
ë¬¸ì œì˜ ì¡°ê±´ì„ ì§ì ‘ ì¶©ì‹¤íˆ í™•ì¸í•˜ëŠ” ê¸°ì´ˆì ì¸ ë°©ë²•
{% code lang:python %}
def merge_the_tools(string, k):
sub_str = []
for i in range(len(string)):
if string[i] not in sub_str:
sub_str.extend(string[i])
if (i+1) % k == 0:
print(''.join(sub_str))
del sub_str[:]

if **name** == '**main**':
string, k = input(), int(input())
merge_the_tools(string, k) {% endcode %}
{% endnote %}

{% note success %}
~main í•¨ìˆ˜ì¼ ë•Œ ì‹¤í–‰í•œë‹¤ëŠ” ì½”ë“œëŠ” ìƒëµ~

- textwrapì€ ì§€ë‚œ ë¬¸ì œì—ì„œ ë‹¤ë¤˜ì§€ë§Œ OrderedDict íŒ¨í‚¤ì§€ëŠ” ì²˜ìŒë´¤ì§€ë§Œ ì´ëŸ° ë°©ë²•ë„ ìˆë‹¤
  {% code lang:python %}
  from collections import OrderedDict
  import textwrap

def merge_the_tools(string, k):
b=textwrap.wrap(string,k)
for i in range (len(b)):
print("".join(OrderedDict.fromkeys(b[i]))) {% endcode %}

- ê°€ì¥ ì¸ê¸°ê°€ ë†’ì€ í•´ë‹µ
- [Discussion forum](https://www.hackerrank.com/challenges/merge-the-tools/forum) ì°¸ê³ !
  {% code lang:python %}
  S, N = input(), int(input())
  for part in zip(_[iter(S)] _ N):
  d = dict()
  print(''.join([ d.setdefault(c, c) for c in part if c not in d ])) {% endcode %}
  {% endnote %}

---

---
