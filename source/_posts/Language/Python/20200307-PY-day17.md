---
title: (PYTHON) Day - 17 Collections(2)
date: 2020-03-07 00:06:47
categories:
  - LANGUAGE ğŸš€
  - PYTHON
  - HACKERRANK
tags: [íŒŒì´ì¬, programming language, python, language]
subtitle: ê¸°ì´ˆë¥¼ íƒ„íƒ„íˆ!
---

# Reference

- ë¬¸ì œ ì¶œì²˜ - [HackerRank](https://www.hackerrank.com/dashboard)
- íŒŒì´ì¬ ì—°ìŠµ - [Practice - Python](https://www.hackerrank.com/domains/python?filters%5Bstatus%5D%5B%5D=unsolved&badge_type=python)

ê°œì¸ì ì¸ ìƒê°ê³¼ ìƒìƒìœ¼ë¡œ ì‘ì„±í•œ ë‚´ìš©ë“¤ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤
ë¬¸ì œë¥¼ í’€ê³  {% label success@ Discussion Tab %}ì„ ì°¸ê³ í•˜ë©° ì½”ë“œ ìŠ¤íƒ€ì¼ì„ ê°œì„ í•˜ë ¤ê³  ë…¸ë ¥í•˜ê³ ì í•©ë‹ˆë‹¤

---

# HackerRank

{% spoiler "HackerRankì˜ Python ì—°ìŠµë¬¸ì œë“¤ì€ ì•„ë˜ì™€ ê°™ì€ ì¹´í…Œê³ ë¦¬ë¡œ ë¶„ë¥˜ ëœë‹¤" %}

## Subdomain

    - ~~Introduction~~
    - ~~Basic Data Types~~
    - ~~Strings~~
    - ~~Sets~~
    - ~~Math~~
    - ~~Itertools~~
    - <strong style="color:blue">Collections</strong>
    - Date and Time
    - Errors and Exceptions
    - Classes
    - Built-Ins
    - Python Functionals
    - Regex and Parsing
    - XML
    - Closures and Decorators
    - Numpy
    - Debugging

{% endspoiler %}

---

# Collections

{% note no-icon %}
{% note primary no-icon %}

## Problem

- [collections.Counter()](#collections-Counter)
- [DefaultDict Tutorial](#DefaultDict-Tutorial)
- [collections.namedtuple()](#collections-namedtuple)
- [collections.OrderedDict()](#collections-OrderedDict)
- [Word Order](#Word-Order)
- [collections.deque()](#collections-deque)
- [company Logo](#company-Logo)
- [Piling Up!](#Piling-Up)
  {% endnote %}

---

## collections.Counter()

</br>

{% note info %}
ë¬¸ì œ : ì‹ ë°œ ê°€ê²Œê°€ ì‹ ë°œì„ íŒë§¤í•´ì„œ ë²ˆ ìˆ˜ì…ì„ êµ¬í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ì‹ ë°œ ê°œìˆ˜ X; (X ë°˜ë³µ) ë³´ìœ í•œ ì‹ ë°œ ì‚¬ì´ì¦ˆ; ì†ë‹˜ ìˆ˜ N; (N ë°˜ë³µ) êµ¬ë§¤í•œ ì‹ ë°œì˜ ì‚¬ì´ì¦ˆ, ê°€ê²©;
ì¶œë ¥ : ì´ ë§¤ì¶œ
{% endnote %}

{% tabs example1, -1 %}

  <!-- tab INPUT @code -->

10
2 3 4 5 6 8 7 6 5 18
6
6 55
6 45
6 55
4 40
18 60
10 50

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

200

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
ê³ ê°ë“¤ì˜ êµ¬ë§¤ë‚´ìš©ë„ ë¯¸ë¦¬ ì…ë ¥ë°›ê³  ê³„ì‚°í•˜ë ¤ê³  í–ˆì§€ë§Œ ë°˜ë³µë¬¸ì„ ëŒë¦¬ê¸° ê¹Œë‹¤ë¡œì›Œì„œ ì…ë ¥ì‹œ ë°”ë¡œë°”ë¡œ ì²˜ë¦¬í•˜ëŠ” ì‹ìœ¼ë¡œ êµ¬í˜„. êµ³ì´ Counter ëª¨ë“ˆì„ ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ í’€ë¦¬ëŠ” ë¬¸ì œ
{% code lang:python %}
X = int(input())
shoes = [int(size) for size in input().split()]
N = int(input())

# customers = {int(size): price for (size, price) in (input().split() for \_ in range(N))}

earned = 0

for \_ in range(N):
size, price = map(int, input().split())
if size in shoes:
earned += price
shoes.remove(size)

print(earned) {% endcode %}
{% endnote %}

{% note success no-icon %}
Counter ëª¨ë“ˆì„ ì‚¬ìš©í•œ êµ¬í˜„
{% code lang:python %}
from collections import Counter

X = int(input())
shoes = [int(size) for size in input().split()]
N = int(input())
shoes_counter = Counter(shoes)
earned = 0

for \_ in range(N):
size, price = map(int, input().split())
if shoes_counter[size] > 0:
earned += price
shoes_counter[size] -= 1

print(earned) {% endcode %}
{% endnote %}

---

## DefaultDict Tutorial

</br>

{% note info %}
ë¬¸ì œ : ê·¸ë£¹ Bì˜ ê° ë¬¸ìë“¤ì´ ê·¸ë£¹ Aì—ì„œ ëª‡ ë²ˆ ë‚˜íƒ€ë‚˜ëŠ”ì§€ êµ¬í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ê·¸ë£¹ Aì˜ ë¬¸ì ìˆ˜ n, ê·¸ë£¹ Bì˜ ë¬¸ììˆ˜ m; (n ë°˜ë³µ) ê·¸ë£¹ A ë¬¸ìë“¤; (m ë°˜ë³µ) ê·¸ë£¹ B ë¬¸ìë“¤;
ì˜ˆì œ : ê·¸ë£¹ AëŠ” (a, a, b, a, b) ê·¸ë£¹ BëŠ” (a, b)ì´ë‹¤
ê·¸ë£¹ Aì—ì„œ 'a'ëŠ” (1 2 4) ìœ„ì¹˜ì— 'b'ëŠ” (3 5) ìœ„ì¹˜ì— ìˆë‹¤
{% endnote %}

{% note info no-icon %}
`defaultdict()` í•¨ìˆ˜ëŠ” ë”•ì…”ë„ˆë¦¬ì— íŠ¹ì • key ê°’ì— valueë¥¼ ë”í•  ë•Œ(append) ìœ ìš©í•˜ê²Œ ì‚¬ìš©ëœë‹¤.
ë”•ì…”ë„ˆë¦¬ì˜ ê¸°ë³¸ ë‚´ì¥í•¨ìˆ˜ì¸ `dict.update()` ëŠ” ê¸°ì¡´ì˜ ê°’ì„ ë®ì–´ë²„ë¦¬ê¸° ë•Œë¬¸ì— ì¶”ê°€ë¡œ ì‚½ì…ì´ í•„ìš”í•  ë•Œ ì‚¬ìš©í•œë‹¤.
{% code lang:python %}
from collections import defaultdict

    d = defaultdict(list)
    d['python'].append("awesome")
    d['something-else'].append("not relevant")
    d['python'].append("language")
    for i in d.items():
        print(i)

    # ë”•ì…”ë„ˆë¦¬ ì‚¬ìš©
    f = dict()
    f.update({'PY': 'AWSOME'})
    f.update({'PY': 'NOT RELEVANT'})    # ê¸°ì¡´ì˜ ê²ƒì„ ë®ì–´ë²„ë¦°ë‹¤
    print(f)    {% endcode %}

{% code lang:python %}
('python', ['awesome', 'language'])
('something-else', ['not relevant'])
{'PY': 'NOT RELEVANT'} {% endcode %}
{% endnote %}

{% tabs example2, -1 %}

  <!-- tab INPUT @code -->

5 2
a
a
b
a
b
a
b

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

1 2 4
3 5

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
{% code lang:python %}
from collections import defaultdict

n, m = map(int, input().split())
gA = defaultdict(list)

for i in range(1, n+1):
gA[input()].append(i)

for \_ in range(m):
b = input()
if b in gA.keys():
print(\*gA[b])
else:
print(-1) {% endcode %}

ë§¤ìš° ê¹”ë”í•˜ê²Œ ì •ë¦¬í•´ ë†“ì€ ì½”ë“œ
{% code lang:python %}
from collections import defaultdict

# Inputs

# ------

n, m = map(int, input().split(' '))

# Let's get the groups as lists

# -----------------------------

#input1 = ['a', 'a', 'b', 'a', 'b']
#input2 = ['a', 'b']
input1 = list()
for i in range(n):
input1.append(input())

      input2 = list()

for i in range(m):
input2.append(input())

# Calculate Output

# ----------------

d = defaultdict(list)

# Fill d with input1 values

for i in range(n):
d[input1[i]].append(i+1)
#print(d) --> defaultdict(<class 'list'>, {'a': [1, 2, 4], 'b': [3, 5]})

# Apply the logic for printing

for i in input2:  
 if i in d:
print(\*d[i])
else:
print(-1) {% endcode %}
{% endnote %}

---

## collections.namedtuple()

</br>

{% note info %}
ë¬¸ì œ : ì£¼ì–´ì§„ datasheetì—ì„œ í•™ìƒë“¤ì˜ ì„±ì (marks)ì˜ í‰ê· ì„ êµ¬í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : (ì…ë ¥ ë°ì´í„° ì°¸ê³ )
ì¶œë ¥ : í‰ê· ì„ ì†Œìˆ˜ì  2ë²ˆì§¸ ìë¦¬ê¹Œì§€ í‘œí˜„
{% endnote %}

{% tabs example3, -1 %}

  <!-- tab INPUT_1 @code -->

5
ID MARKS NAME CLASS  
 1 97 Raymond 7  
 2 50 Steven 4  
 3 91 Adrian 9  
 4 72 Stewart 5  
 5 80 Peter 6

  <!-- endtab -->

  <!-- tab OUTPUT_1 @code -->

78.00

  <!-- endtab -->

  <!-- tab INPUT_1 @code -->

5
MARKS CLASS NAME ID  
 92 2 Calum 1  
 82 5 Scott 2  
 94 2 Jason 3  
 55 8 Glenn 4  
 82 2 Fergus 5

  <!-- endtab -->

  <!-- tab OUTPUT_1 @code -->

81.00

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
êµ³ì´ íŒŒì´ì¬ì„ ì‚¬ìš©í•˜ë©° ì§§ì€ ì½”ë“œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤ê³  í•´ë„... êµ³ì´ ê°€ë…ì„±ì´ ë–¨ì–´ì§€ê²Œ ê·¸ë˜ì•¼í•˜ë‚˜ ì‹¶ë‹¤. ì•„ë˜ ì½”ë“œë„ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ë‚˜ í•´ë‹¹ ì»´íŒŒì¼ëŸ¬ëŠ” 4ì¤„ ì´ë‚´ë¡œ ë¬¸ì œ í•´ê²°ì„ ìš”êµ¬í•œë‹¤.
{% code lang:python %}
from collections import namedtuple

num_of_std = int(input())
attribute = input().split()
students = namedtuple('students', attribute)
total = 0

for \_ in range(num_of_std):
student = students(\*input().split())
total += int(student.MARKS)

print('{:.2f}'.format(total/num_of_std)) {% endcode %}
{% endnote %}

{% note success no-icon %}
{% code lang:python %}
from collections import namedtuple
n, Student = int(input()), namedtuple('Student', input())
print("{:.2f}".format(sum([int(Student(*input().split()).MARKS) for _ in range(n)]) / n)) {% endcode %}

2ì¤„ë¡œ ëë‚´ëŠ” ì´ ì½”ë“œëŠ” ì¡°ê¸ˆ ì‹ ë°•í•˜ë‹¤
{% code lang:python %}
n,ind=int(input()),(input().split()).index('MARKS')
print(sum([float((input().split())[ind]) for i in range(n)])/n,end="0") {% endcode %}
{% endnote %}

---

## collections.OrderedDict()

</br>

{% note info %}
ë¬¸ì œ : ë§ˆì¼“ì—ì„œ ì†Œë¹„ìê°€ êµ¬ë§¤í•´ê°„ ë¬¼ê±´ê³¼ ê°€ê²©ì„ ì¢…í•©í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : êµ¬ë§¤ë‚´ì—­ ê°œìˆ˜ N; (N ë°˜ë³µ) ë¬¼í’ˆ ì´ë¦„, ê°€ê²©;
ì¶œë ¥ : ë¬¼í’ˆ ì´ë¦„, ê°€ê²©ì„ ìˆœì„œëŒ€ë¡œ ì¶œë ¥
{% endnote %}

{% tabs example4, -1 %}

  <!-- tab INPUT @code -->

9
BANANA FRIES 12
POTATO CHIPS 30
APPLE JUICE 10
CANDY 5
APPLE JUICE 10
CANDY 5
CANDY 5
CANDY 5
POTATO CHIPS 30

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

BANANA FRIES 12
POTATO CHIPS 60
APPLE JUICE 20
CANDY 20

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
try/except ë¬¸ìœ¼ë¡œ í•´ë‹¹ ì•„ì´í…œì˜ ìœ ë¬´ì— ë”°ë¥¸ í–‰ë™ì„ ë‹¤ë¥´ê²Œ í–ˆë‹¤
{% code lang:python %}
from collections import OrderedDict

N = int(input())
items = OrderedDict()

for i in range(N):
\*it, price = input().split()
item = ' '.join(it)
try:
items[item] += int(price)
except KeyError:
items[item] = int(price)

for item, price in items.items():
print(item, price) {% endcode %}

`dict.get()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê¸°ë³¸ê°’ì„ ì§€ì •í•´ì„œ í•´ê²°í•˜ëŠ” ë°©ë²•ë„ ìˆë‹¤

{% code lang:python %}
from collections import OrderedDict

N = int(input())
items = OrderedDict()

for i in range(N):
\*it, price = input().split()
item = ' '.join(it)
items[item] = items.get(item, 0) + int(price)

for item, price in items.items():
print(item, price) {% endcode %}
{% endnote %}

---

## Word Order

</br>

{% note info %}
ë¬¸ì œ : ì„œë¡œ ë‹¤ë¥¸ ë¬¸ìì—´ì´ ëª‡ ê°œì¸ì§€ êµ¬í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ì…ë ¥ë°›ì„ ê°œìˆ˜ N; (N ë°˜ë³µ) ë¬¸ìì—´ ì…ë ¥;
ì¶œë ¥ : ì„œë¡œ ë‹¤ë¥¸ ë¬¸ìì—´ì˜ ìˆ˜; ê° ë¬¸ìì—´ì˜ ê°œìˆ˜;
ì˜ˆì œ : 'bcdef'ëŠ” 2ë²ˆ ì¶œí˜„í•˜ê³  ë‚˜ë¨¸ì§€ 'abcdefg', 'bcde'ëŠ” ê° 1ë²ˆì”© ì¶œí˜„
{% endnote %}

{% tabs example5, -1 %}

  <!-- tab INPUT @code -->

4
bcdef
abcdefg
bcde
bcdef

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

3
2 1 1

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
{% code lang:python %}
from collections import Counter

N = int(input())
words = [input() for _ in range(N)]
words_counter = Counter(words)

print(len(words_counter))
print(\*words_counter.values()) {% endcode %}
{% endnote %}

---

## collections.deque()

</br>

{% note info %}
ë¬¸ì œ : dequeë¥¼ ìƒì„±í•˜ê³  ê° ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•œ ë’¤ ê²°ê³¼ê°’ì„ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ëª…ë ¹ì–´ ê°œìˆ˜ N; (N ë°˜ë³µ) ëª…ë ¹ì–´, ê°’;
ì¶œë ¥ : dequeì— ìˆëŠ” ìš”ì†Œë“¤
{% endnote %}

{% tabs example6, -1 %}

  <!-- tab INPUT @code -->

6
append 1
append 2
append 3
appendleft 4
pop
popleft

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

1 2

  <!-- endtab -->

{% endtabs %}

{% note default no-icon %}
`eval()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì¡°ê¸ˆ ê¹Œë‹¤ë¡œìš´ë“¯...
{% code lang:python %}
from collections import deque
d = deque()
for \_ in range(int(input())):
eval('d.{0}({1})'.format(*input().split(), ''))
print(*d) {% endcode %}
{% endnote %}

{% note success no-icon %}
`getattr()` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ëª…ë ¹ì–´ ìˆ˜í–‰
{% code lang:python %}
from collections import deque

N = int(input())
d = deque()

for \_ in range(N):
method, *arg = input().split()
getattr(d, method)(*arg)

print(\*d) {% endcode %}
{% endnote %}

---

## company Logo

</br>

{% note info %}
ë¬¸ì œ : ë¬¸ìì—´ì—ì„œ ê°€ì¥ ë¹ˆë„ìˆ˜ê°€ ë†’ì€ ë‹¨ì–´ 3ê°œë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : ë¬¸ìì—´
ì¶œë ¥ : ë¬¸ì, ë¬¸ì ìˆ˜
{% endnote %}

{% tabs example8, -1 %}

  <!-- tab INPUT @code -->

aabbbccde

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

b 3
a 2
c 2

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
{% code lang:python %}
from collections import Counter

words = Counter(sorted(input()))
[print(*w) for w in words.most_common(3)]
{% endcode %}
{% endnote %}

---

## Piling Up!

</br>

{% note info %}
ë¬¸ì œ : íŠ¹ì • ê·œì¹™ì„ ë§Œì¡±í•˜ë©´ì„œ íë¸Œë¥¼ ìŒ“ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë¬¸ì œ
ì…ë ¥ : í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ ìˆ˜ T; (íë¸Œì˜ ìˆ˜ n; ê° íë¸Œì˜ ê°€ë¡œê¸¸ì´;)
ì¶œë ¥ : Yes/No ë¡œ ì¶œë ¥
ì˜ˆì œ : íë¸ŒëŠ” ì™¼ìª½/ì˜¤ë¥¸ìª½ ëì—ì„œë§Œ ë¨¼ì € ê°€ì ¸ì˜¬ ìˆ˜ ìˆìœ¼ë©° ë°‘ì— ê¹”ë¦¬ëŠ” íë¸Œì˜ ê¸¸ì´ê°€ ë” ê¸¸ì–´ì•¼ í•œë‹¤.
ì²«ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œëŠ” 4-4-3-3-2-1 ìˆœìœ¼ë¡œ ìŒ“ì„ ìˆ˜ ìˆê¸°ì— Yes
ë‘ë²ˆì§¸ ì¼€ì´ìŠ¤ì—ì„œëŠ” 1ìœ„ì— 2ë‚˜ 3ì„ ìŒ“ì„ ìˆ˜ ì—†ê¸°ì— No ê°€ ëœë‹¤
{% endnote %}

{% tabs example7, -1 %}

  <!-- tab INPUT @code -->

2
6
4 3 2 1 3 4
3
1 3 2

  <!-- endtab -->

  <!-- tab OUTPUT @code -->

Yes
No

  <!-- endtab -->

{% endtabs %}

{% note success no-icon %}
íŒŒì´ì¬ì—ì„œëŠ” for-else ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
forë¬¸ì´ ëê¹Œì§€ ìˆ˜í–‰ë˜ë©´ else ë¬¸ì˜ ë‚´ìš©ì´ ì‹¤í–‰ëœë‹¤.
{% code lang:python %}
from collections import deque

for _ in range(int(input())):  
 _, queue = input(), deque(map(int, input().split()))

      for cube in reversed(sorted(queue)):
          if queue[-1] == cube:
              queue.pop()
          elif queue[0] == cube:
              queue.popleft()
          else:
              print('No')
              break
      else:
          print('Yes') {% endcode %}

    í˜¹ì€ ìµœì†Œê°’ì„ ê¸°ì¤€ìœ¼ë¡œ ì¢Œìš° ë¦¬ìŠ¤íŠ¸ë¥¼ ë¶„ë¦¬í•˜ì—¬ ì •ë ¬ëœ ê°’ê³¼ ë¹„êµí•˜ëŠ” ë°©ë²•ë„ ìˆë‹¤
    {% code lang:python %}
      for T in range(int(input())):
      n, queue = input(), [int(i) for i in input().split()]
      min_idx = queue.index(min(queue))
      left_q = queue[:min_idx]
      right_q = queue[min_idx+1:]

      if left_q == sorted(left_q, reverse=True) and right_q == sorted(right_q):
          print("Yes")
      else:
          print("No") {% endcode %}

{% endnote %}

{% endnote %}

---

---
